var Stippling=function(t){"use strict";function i(t,i,n){const r=t.createShader(i);if(t.shaderSource(r,n),t.compileShader(r),!t.getShaderParameter(r,t.COMPILE_STATUS)){const i=new Error("An error occurred compiling the shaders: "+t.getShaderInfoLog(r));throw t.deleteShader(r),i}return r}const n={multiply(t,i){const n=t[0],r=t[1],e=t[2],a=t[3],s=t[4],o=t[5],h=t[6],c=t[7],d=t[8],m=i[0],u=i[1],g=i[2],f=i[3],l=i[4],w=i[5],v=i[6],p=i[7],x=i[8];return[m*n+u*a+g*h,m*r+u*s+g*c,m*e+u*o+g*d,f*n+l*a+w*h,f*r+l*s+w*c,f*e+l*o+w*d,v*n+p*a+x*h,v*r+p*s+x*c,v*e+p*o+x*d]},translation:(t,i)=>[1,0,0,0,1,0,t,i,1],scaling:(t,i)=>[t,0,0,0,i,0,0,0,1],identity:()=>[1,0,0,0,1,0,0,0,1]};async function r(t){const i=await async function(t){return new Promise((i,n)=>{const r=new Image;r.onload=()=>i(r),r.onerror=()=>n(),r.onabort=()=>n(),r.src=t})}(t),n=function(t){let i=Math.min(window.innerWidth,600,t.width),n=t.height/t.width*i;return n>800&&(n=800,i=t.width/t.height*n),[i,n]}(i),r=function(t){const i="OffscreenCanvas"in window?new OffscreenCanvas(t[0],t[1]):document.createElement("canvas");return i.width=t[0],i.height=t[1],i.getContext("2d")}(n);return r.drawImage(i,0,0,i.width,i.height,0,0,...n),r.getImageData(0,0,...n)}class e{constructor(t,r,e,a){this.srcLoc=-1,this.dstLoc=-1,this.srcMatrix=n.identity(),this.dstMatrix=n.identity(),this.animationTimeStart=0,this.animating=!1,this.currentImage="",this.canvas=t,this.animationDuration=a,this.n=e;const s=this.canvas.getContext("webgl");if(null===s)throw new Error("Unable to initialize WebGL. Your browser or machine may not support it.");this.gl=s,this.program=function(t,n,r){const e=i(t,t.VERTEX_SHADER,n),a=i(t,t.FRAGMENT_SHADER,r),s=t.createProgram();if(t.attachShader(s,e),t.attachShader(s,a),t.linkProgram(s),!t.getProgramParameter(s,t.LINK_STATUS)){const i=new Error("Unable to initialize the shader program: "+t.getProgramInfoLog(s));throw t.deleteProgram(s),i}return s}(s,"\nattribute vec2 a_src;\nattribute vec2 a_dst;\n\nuniform vec2 u_resolution;\nuniform mat3 u_smatrix;\nuniform mat3 u_dmatrix;\nuniform float u_time;\n\nvoid main() {\n  vec2 src = (u_smatrix * vec3(a_src, 1)).xy;\n  vec2 dst = (u_dmatrix * vec3(a_dst, 1)).xy;\n  vec2 position = src + ((dst - src) * u_time);\n  vec2 zeroToOne = position / u_resolution;\n  vec2 zeroToTwo = zeroToOne * 2.0;\n  vec2 clipSpace = zeroToTwo - 1.0;\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n  gl_PointSize = 6.0;\n}\n","\nprecision mediump float;\n\nvoid main() {\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n  float r = dot(cxy, cxy);\n  float alpha = 1.0 - smoothstep(0.1, 0.5, r);\n  if (r > 1.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0) * alpha;\n}\n"),this.dstLoc=s.getAttribLocation(this.program,"a_dst"),this.srcLoc=s.getAttribLocation(this.program,"a_src"),this.resolutionLoc=s.getUniformLocation(this.program,"u_resolution"),this.srcMatrixLoc=s.getUniformLocation(this.program,"u_smatrix"),this.dstMatrixLoc=s.getUniformLocation(this.program,"u_dmatrix"),this.timeLoc=s.getUniformLocation(this.program,"u_time"),this.srcBuffer=s.createBuffer(),this.dstBuffer=s.createBuffer(),this.worker=new Worker(r),this.worker.addEventListener("message",this.messageHandler.bind(this))}updatePoints(t,i){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,i?this.dstBuffer:this.srcBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,t,this.gl.STATIC_DRAW),i&&(this.dstPoints=t)}async start(){const t=this.n,{width:i,height:n}=this.canvas,r=new Float32Array(2*t),e=new Float32Array(2*t);for(let t=0;t<this.n;t++)e[2*t]=Math.floor(Math.random()*i),e[2*t+1]=Math.floor(Math.random()*n),r[2*t]=r[2*t+1]=0;this.updatePoints(r,!1),this.updatePoints(e,!0),this.animationTimeStart=0,this.nextTic()}nextTic(){requestAnimationFrame(t=>this.tic(t))}tic(t){let i=1;this.animating&&(this.animationTimeStart||(this.animationTimeStart=t),i=Math.min(1,(t-this.animationTimeStart)/this.animationDuration));const n=this.gl;!function(t,i=1){const n=t.clientWidth*i|0,r=t.clientHeight*i|0;(t.width!==n||t.height!==r)&&(t.width=n,t.height=r)}(this.canvas),n.viewport(0,0,n.canvas.width,n.canvas.height),n.enable(n.BLEND),n.blendFunc(n.ONE,n.ONE_MINUS_SRC_ALPHA),n.useProgram(this.program),n.bindBuffer(n.ARRAY_BUFFER,this.srcBuffer),n.enableVertexAttribArray(this.srcLoc),n.vertexAttribPointer(this.srcLoc,2,n.FLOAT,!1,0,0),n.bindBuffer(n.ARRAY_BUFFER,this.dstBuffer),n.enableVertexAttribArray(this.dstLoc),n.vertexAttribPointer(this.dstLoc,2,n.FLOAT,!1,0,0),n.uniform2f(this.resolutionLoc,n.canvas.width,n.canvas.height),n.uniform1f(this.timeLoc,i),n.uniformMatrix3fv(this.srcMatrixLoc,!1,this.srcMatrix),n.uniformMatrix3fv(this.dstMatrixLoc,!1,this.dstMatrix),n.drawArrays(n.POINTS,0,this.n),i<1?this.nextTic():this.animating&&(this.animating=!1)}update(t){this.dstPoints&&this.updatePoints(this.dstPoints,!1),this.updatePoints(t.points,!0),this.srcMatrix=this.dstMatrix;const i=Math.min(this.canvas.width/t.width,this.canvas.height/t.height),r=(this.canvas.width-t.width*i)/2,e=(this.canvas.height-t.height*i)/2;this.dstMatrix=n.multiply(n.translation(r,e),n.scaling(i,i)),this.animationTimeStart=0,this.animating||(this.animating=!0,this.nextTic())}async drawImage(t,i){if(i||this.currentImage!==t){this.currentImage=t;const i=await r(t);if(this.currentImage!==t)return;if(i.width&&i.height){const n={buffer:i.data.buffer,height:i.height,width:i.width,pointCount:this.n,name:t};this.worker.postMessage(n,[i.data.buffer])}}}async messageHandler(t){const i=t.data;this.update(i)}}return t.canvas=function(t,i,n=5e3,r=1e3){return new e(t,i,n,r)},t}({});
